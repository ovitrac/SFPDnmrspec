function [W,Wrelative,dbout,outplot] = nmrlsqnonneg(dbcorrsub,dbcorrmix,varargin)
%NMRLSQNONNEG uses lsqnonneg for deconvolution of NMR spectra from correlation matrices calculated by NMRLOADMATRIX according to number of inserted substance
% SYNTAXES
%       C = nmrlsqnonneg(dbcorrsub,dbcorrmix,'nmoltest',10)
% INPUTS
%            DBCORRSUB: n x m matrix of correlation (corr. function) between substances generated by NMRLOADMATRIX
%                       matrix is organized in rang of insertion of substances (1st row = 1st inserted substance)
%            DBCORRMIX: n x 1 matrix of correlation (corr. function) between substances and mixture(s) generated by NMRLOADMATRIX
%                       matrix is organized in rang of insertion of substances
%  VARARGIN
%             nmoltest: numeric, total number of inserted substances in deconvolution procedure (default = [] = size(dbcorrsub,1)
%            proximity: n x 1 array, rang of susbtances by proximity (by calculation of clustering and conversion to ordered proximity 1:n) (default = [], no ranking by proximity)
%                    P: n x 1 array, number of proton of susbtances ordered in rang of insertion of substances
%                   Mw: n x 1 array, molecular mass of susbtances ordered in rang of insertion of substances
%                dbfit: theoretical , fitted NMR database containing substances
%               dbxpur: nmr database containing real substance spectra data
%                dbpur: nmr database containing real substance spectra data
%     calibrationvalue: value of calibration (in dbcalibration) (default=9.58e+6)
%          errorfactor: factor of experimental error for conversion into concentration (default=3)
%       solventdensity: density of solvent for covnersion into concentration (default=1.5);
%             prctiles: percentiles to calculate concentration (default=[0 5 10 25 50 75 90 95 100])
%             colormap: colormap for tree graph (default=jet(64))
%         valuestoplot: value of conc to plot (choose among caculated percentiles (default='conc_p50')
%              concmin: conc minimal (default = 1)
%              concmax: conc maximal (default = +Inf)
%        fontsizegraph: fontsize for graph (default = 10)
%        linewidthgrap: linewidth for graph (default = 2)
%
%   OUTPUTS
%       W and Wrelative: n x 1 cell array containing proportion and relative proportion of spectrum for all combinations
%                       W{1}: 1x1 array 
%                       W{2}: 2xk array (k: numbers of combinations when choosing 2 substances)
%                       W{3}: 3xk array (k: numbers of combinations when choosing 3 substances)
%                        .
%                        .
%                        .
%                       W{n}: nx1 array
%
%           dbout.indmol: n x 1 cell array containing all combinations (same dimension as W)
%       dbout.molpercase: m x 1 array, number of inserted susbtances for each combination
%                dbout.X: molar fraction
%      dbout.(substance): structure containing
%                      W: proprotion of spectrum (as W ordered by substance) 
%              Wrelative: relative proprotion of spectrum (as Wrelative ordered by substance) 
%                      X: molar fraction
%
%        outplot.Wtabout: m x n array containing proportion of spectrum for all combinations m = sum(k)
%     outplot.Wreltabout: m x n array containing relative proportion of spectrum for all combinations m = sum(k)
%        outplot.Ctabout: m x n array containing concentration in mg/kg of spectrum for all combinations m = sum(k) (taking into account some hypothesis about experimental error
%                       NaN : susbtance not inserted
%                       numeric values : output of lsqnonneg
%          outplot.xplot: m x 1 array data for xaxis for plot by Wtabout
%        outplot.ninsert: m x 1 array, number of inserted susbtances for each combination
%   outplot.Caveragetab : n x n : average concentration (Ctabout) ordered by susbtances (in column) and by insertion rank (in row)
%
%
% See also: nmrloadmatrix, createcombination
%
% RMNSPEC v 0.1 - 05/12/2013 - INRA\Olivier Vitrac, LNE\Mai Nguyen - rev. 23/09/2014
%
% history
% 10/12/2013 add additional (dbout) outputs
% 24/01/2014 add additional outputs (Wtabout)
% 25/01/2014 add tree representation via Tmost (to be controlled mainly via nmoltree)
% 23/09/2014 add outplot.class (return class/proximity of susbtances for plot)
%                outplot.substancename (return names of substances inserted for plot)
%                outplot.graph.colormap in output  (return colormap scale of graph for plot)

% default
default = struct('nmoltest',[],'proximity',[],'P',[],'Mw',[],'dbfit',[],'dbxpur',[],'dbpur',[],...
    'calibrationvalue',9.58e+6,'errorfactor',3,'solventdensity',1.5,'nmoltree',4,...
    'prctiles',[0 5 10 25 50 75 90 95 100],'colormap',jet(64),... added OV
    'valuestoplot','conc_p50','concmin',0,'concmax',+Inf,'fontsizegraph',10,'linewidthgraph',2); % added OV
keyword = {'convert2molar'};

% argcheck
o = argcheck(varargin,default,keyword,'nostructexpand');
if nargin < 2, error('2 argument are required'), end
if ~isstruct(dbcorrsub) || ~isfield(dbcorrsub,'corrmax') || ~isfield(dbcorrsub,'corrzerolag') || ~isfield(dbcorrsub,'rho2') || ~isfield(dbcorrsub,'subtestlist') || ~isfield(dbcorrsub,'subreflist')    
    error('DBCORRSUB must be created by NMRLOADMATRIX')
end
if ~isstruct(dbcorrmix) || ~isfield(dbcorrmix,'corrmax') || ~isfield(dbcorrmix,'corrzerolag') || ~isfield(dbcorrmix,'rho2') || ~isfield(dbcorrmix,'subtestlist') || ~isfield(dbcorrmix,'subreflist')    
    error('DBCORRMIX must be created by NMRLOADMATRIX')
end
if size(dbcorrsub,1) ~=  size(dbcorrmix,1), error('DBCORRSUB and DBCORRMIX must have a same size (fisrt direction, in row)'), end
if size(dbcorrmix,2) > 1, warning('Only first mixture will be studied'), dbcorrmix = dbcorrmix(:,1); end
if isempty(o.nmoltest), o.nmoltest = size(dbcorrsub,1); end
if isempty(o.proximity), o.proximity = 1:o.nmoltest; end
if o.convert2molar && isempty(o.P), error('array P (number of proton) is required for conversion of spectra proportion into molar fractions'), end
if isempty(o.dbxpur), [~,o.dbxpur] = nmrloadbase; end % load dbxpur NMR spectra database
if isempty(o.dbpur), o.dbpur = nmrloadbase; end % load dbpur NMR spectra database
if isempty(o.dbfit), o.dbfit = nmrloaddbfit('path',fullfile(find_path_toolbox('rmnspec'),'data_pur'),'dbname','dbfit.mat'); end % load dbfit of NMR database
if ~isempty(o.dbxpur) &&  ~isempty(o.dbpur) &&  ~isempty(o.dbfit) && isempty(o.Mw), error('array Mw (molecular mass) is required for conversion of spectra proprtion into concentration'), end
o.nmoltree = min(o.nmoltree,o.nmoltest);
o.prctiles = unique(round(max(min(o.prctiles,100),0))); 

entitytest = 1:size(dbcorrsub,1); 
class = o.proximity(1:length(entitytest));
substancename = {dbcorrsub(:,1).subtestlist};

% main
W = cell(o.nmoltest,1); % result of lisqnonneg for nmoltest (fraction of spectra)
Wrel = cell(o.nmoltest,1); % fraction relative of spectra 
X = cell(o.nmoltest,1); % molar fraction based on C
indmol = cell(o.nmoltest,1); % combinations associated to calculated C
Wrelativeout = cell(o.nmoltest,1); % relative fraction of spectrum ordered by substances (as Crel)
Wout = cell(o.nmoltest,1); % proportion of spectrum ordered by substances (as C)
Xout = cell(o.nmoltest,1);  % molar fraction ordered by substances
C = cell(o.nmoltest,1); % concentration in ppm of material

% --- all combinations (by OV)
mostsignificant = 1:o.nmoltree; % first substances to be considered (not all)
indmoltree = createcombination(entitytest(mostsignificant),class(mostsignificant),mostsignificant);  % combinations associated to calculated C
Tmost = removerepeatedcombinations(indmoltree,o.nmoltest,o.prctiles);  % as above but more compact
nodestoupdate = @(mixture) Tmost.paths(isincluded(Tmost.pathsN,Tmost.Nall(mixture)));
% -- end all combindations

P = zeros(o.nmoltest,o.nmoltest); % presence matrix
for i = 1:o.nmoltest
    % generate combinations when choosing i molecules between
    combout = createcombination(entitytest,class,i);   %?? pourquoi dans la boucle
    Wtmp = zeros(i,size(combout,1));
    Wreltmp = zeros(i,size(combout,1));
    Xtmp = zeros(i,size(combout,1));  
    Ctmp = zeros(i,size(combout,1));
    bad = zeros(i,1);
    for j = 1:size(combout,1)        
        dbcsub = dbcorrsub(combout(j,:),combout(j,:));
        dbcmix = dbcorrmix(combout(j,:),:);    
        Ptmp = o.P(combout(j,:)); % number of proton
        Mwtmp = o.Mw(combout(j,:)); % molecular mass
        Wtmp(:,j) = lsqnonneg(cell2mat(reshape({dbcsub.corrmax},size(dbcsub))),cell2mat(reshape({dbcmix.corrmax},size(dbcmix))));
        % supplementary rule : bad = molecule having W=0 at its intrinsec rank but appears after
        newcomb = 1:i;
        promoted = (combout(j,:)>(1:i))';
        if ~any(promoted)
            P(i,combout(j,:)) = (Wtmp(:,j) > 0); %if length(combout(j,:))>1 %all(combout(j,:)<=i)
            diagP = diag(P);
        end
        if ~any(promoted(combout(j,:)<=i)) &&  any(~diagP(combout(j,Wtmp(:,j)>0)))
            tmp = combout(j,Wtmp(:,j)>0); 
            bad = tmp(~diagP(combout(j,Wtmp(:,j)>0))); 
            if ~isempty(bad) && length(bad)<i
                [~,newcomb] = setdiff(combout(j,:),bad); %combout(j,~bad);  
                [~,ibad] = setdiff(combout(j,:),combout(j,newcomb));
                dbcsub = dbcorrsub(newcomb,newcomb);
                dbcmix = dbcorrmix(newcomb,:);    
                Wtmp(newcomb,j) = lsqnonneg(cell2mat(reshape({dbcsub.corrmax},size(dbcsub))),cell2mat(reshape({dbcmix.corrmax},size(dbcmix))));
                Wtmp(ibad,j) = 0;
            end
        end   
        Wreltmp(newcomb,j) = Wtmp(newcomb,j)/nansum(Wtmp(newcomb,j));
        
        % conversion into concentration
        tmpspec = nmrbuildtheospec(substancename(combout(j,:)),o.dbfit,o.dbxpur,Wreltmp(:,j),'Ifit');
        totalareatmp = trapz(o.dbxpur.ppm,tmpspec(:,2));
        normvalue = cellfun(@(m) o.dbpur.(m).normvalue,substancename(combout(j,:))); 
        molarptmp = Wreltmp(:,j).*totalareatmp.*normvalue'/o.calibrationvalue ; % molar concentration  in proton molH/L
        Ctmp(:,j) = (molarptmp.*Mwtmp./Ptmp)*1000*o.errorfactor/o.solventdensity; %
        
        % conversion into molar fraction
        if o.convert2molar
            Cavlb = Wtmp((Wtmp(:,j)~=0),j);
            Ptmp = Ptmp((Wtmp(:,j)~=0));
            % pairwise ratios
            if i==1, x = 1;
            else
                r = (Cavlb(1:end-1).*Ptmp(2:end))./(Ptmp(1:end-1).*Cavlb(2:end));
                x = ratio2fraction(r); % conversion ratio to fraction
            end
            Xtmp((Wtmp(:,j)~=0),j) = x;
        end
        
        % --- store concentrations in tree as Tmost.T.(node).conc (OV)
        nodes = nodestoupdate(combout(j,:)); % list of npodes to be updated (OV)
        for ibranch = 1:length(nodes)
            for k = 1:min(i,length(nodes{ibranch}))
                Tmost.T.(nodes{ibranch}{k}).conc(end+1) = Ctmp(k,j);
            end
        end 
        % --- end store
        
        % order by susbtances
        for k = 1:i
            Wout{combout(j,k)} = vertcat(Wout{combout(j,k)},Wtmp(k,j));
            Wrelativeout{combout(j,k)} = vertcat(Wrelativeout{combout(j,k)},Wreltmp(k,j));
            if o.convert2molar, Xout{combout(j,k)} = vertcat(Xout{combout(j,k)},Xtmp(k,j)); end
        end
    end
    W{i} = Wtmp;
    indmol{i} = combout;
    Wrel{i} = Wreltmp;
    X{i} = Xtmp;
    C{i} = Ctmp;
end

% --- average stored concentrations
for n = Tmost.nodes(:)'
    for p = o.prctiles(:)'
        Tmost.T.(n{1}).(sprintf('conc_p%02d',p)) =  prctile(Tmost.T.(n{1}).conc,p);
    end
    Tmost.T.(n{1}).conc_mean = mean(Tmost.T.(n{1}).conc);
    Tmost.T.(n{1}).conc_meanpos = mean(Tmost.T.(n{1}).conc(Tmost.T.(n{1}).conc>0));
end
Tmost.fieldtoplot  = o.valuestoplot;
Tmost.valuestoplot = cell2struct(cellfun(@(n) Tmost.T.(n).(o.valuestoplot),Tmost.nodes,'UniformOutput',false),Tmost.nodes);
if isinf(o.concmax),  o.concmax = max(Tmost.valuestoplot); end
Tmost.valuesmin = o.concmin;
Tmost.valuesmax = o.concmax;
% --- end average concentrations

% construct of outplot
ncase = sum(cell2mat(arrayfun(@(i) size(indmol{(i)},1),1:o.nmoltest,'uniformoutput',false)')); % size all combinations
molpercase = zeros(ncase,1);
Wtab = NaN(ncase,o.nmoltest); % table in W
Wreltab = NaN(ncase,o.nmoltest); % table in Wrelative
Ctab =  NaN(ncase,o.nmoltest); % table in concentration in ppm unit
xplot = zeros(ncase,1);
k = 1;
for i = 1:o.nmoltest
    xplot(k+(0:size(indmol{i},1)-1)) = i + 0.3*linspace(-(size(indmol{i},1)-1),size(indmol{i},1)-1,size(indmol{i},1))/size(indmol{i},1);
    for j = 1:size(indmol{i},1) % by case 
        imolinsert = indmol{i}(j,:);
        Wtab(k,imolinsert) = W{i}(:,j);
        Wreltab(k,imolinsert) = Wrel{i}(:,j);
        Ctab(k,imolinsert) = C{i}(:,j);
        molpercase(k) = i;
        k = k+1;
    end
end

% table of average concentration of each susbtances when insert i molecules
Caveragetab =  NaN(o.nmoltest,o.nmoltest);
for imol = 1:o.nmoltest % per susbtance
    for i = 1:o.nmoltest % per ninsert
        Caveragetab(i,imol) = nanmean(Ctab(molpercase==i,imol)); 
    end
end
    
% output
if nargout>1, Wrelative = Wrel; end 
if nargout>2
    dbout.C = C;
    dbout.indmol = indmol;
    dbout = catstruct(Tmost,dbout);
    if o.convert2molar, dbout.X = X; end
    for i = 1:o.nmoltest
        dbout(1).(substancename{i}).W = Wout{i};
        dbout(1).(substancename{i}).Wrelative = Wrelativeout{i};
        if o.convert2molar, dbout(1).(substancename{i}).X = Xout{i}; end
    end
    dbout.Tmost = Tmost; % added output by OV
end
if nargout > 3
    outplot.substancename = substancename;
    outplot.xplot = xplot;
    outplot.ninsert = molpercase;
    outplot.Wtabout = Wtab;
    outplot.Wreltabout = Wreltab;
    outplot.Ctabout = Ctab;
    outplot.Caveragetab = Caveragetab;
    outplot.presencematrix = P;
    % do the graph for future use (added OV)
    hgraph = fmecagraph(Tmost.T,Tmost.valuestoplot,'names',Tmost.nodesN,'nobiograph',...
        'min',Tmost.valuesmin,'max',Tmost.valuesmax,'colormap',o.colormap,'fontsize',o.fontsizegraph,'defaultlinewidth',o.linewidthgraph); drawnow
    outplot.graph = struct('paperposition',get(hgraph,'paperposition'),'figuredata',gcfd(hgraph),'colormap',o.colormap);
    delete(hgraph)
end


end

%% ============================
%      PRIVATE FUNCTIONS
% > they are not nested functions
%   they work in their own name space
%  ============================

% REMOVEREPEATEDCOMBINATIONS: clean the sequence created by CREATECOMBINATION (for tree plot)
function out = removerepeatedcombinations(combinations,nmax,prctiles)
nc = length(combinations);
for ic = 1:nc-1
    [n,m] = size(combinations{ic});
    tobedeleted = false(n,1);
    for j=1:size(combinations{ic},1)
        icnext = ic;
        while ~tobedeleted(j) && icnext<nc
            icnext = icnext + 1;
            tobedeleted(j) = ismember(combinations{ic}(j,:),combinations{icnext}(:,1:m),'rows');
        end
    end
    combinations{ic}(tobedeleted,:) = [];
end
% cast all outputs as single structure
clean = @(c)regexprep(c,'r\d*$','');
out.combinations = combinations(~cellfun(@isempty,combinations)); % remove empty entries
[out.T,out.N,out.Nall] = buildcombinationtree(out.combinations,nmax,prctiles); % tree and names
out.nodes = fieldnames(out.T);                 % node tree  (real ones)
out.nodesN = cell2struct(clean(out.nodes),out.nodes);                 % nodes based on names
out.paths = buildmarkov(out.T);                % build all paths
out.pathsN = cellfun(clean,out.paths,'UniformOutput',false);
end

% BUILDCOMBINATIONTREE builds a tree from simplified combinations
function [T,subscode,allcodes] = buildcombinationtree(combinations,nmax,prctiles)
% build tree (append nodes when required to enfore the rule: one single parent per node)
codegenerator = @(m) sprintf('%s',char(96+m));
nodedefault = catstruct(...
    struct('parent','','inherit','','isterminal',false,...
    'conc',[],'conc_mean',[],'conc_meanpos',[]),...
    cell2struct(repmat({[]},1,length(prctiles)),arrayfun(@(p) sprintf('conc_p%02d',p),prctiles,'UniformOutput',false),2) ...
);
n = 1:max(cellfun(@length,combinations));
repetitions = zeros(n(end),1);
T = struct([]);
allcodes = arrayfun(codegenerator,1:nmax,'UniformOutput',false);
subscode = arrayfun(codegenerator,n,'UniformOutput',false);
for ic = 1:length(combinations)
    for ip=1:size(combinations{ic},1)
        % current path
        codep = combinations{ic}(ip,:);
        p0 = subscode(combinations{ic}(ip,:)); p = p0;
        for i=1:length(p)
            currentnode = p{i};
            if i==1, parentnode = ''; else parentnode = p{i-1}; end
            % check whether a different parent node exist
            if ~isempty(parentnode) && isfield(T,currentnode) && ~strcmp(T.(currentnode).parent,parentnode)
                for j = i:length(p);
                    repetitions(codep(j)) = repetitions(codep(j)) + 1;
                    p{j} = sprintf('%sr%02d',p0{j},repetitions(codep(j))); %sprintf('%s%s',p0{j},char(96+repetitions(codep(j))));
                end
                currentnode = p{i};
            end
            % refresh tree
            if ~isfield(T,currentnode), T(1).(currentnode) = nodedefault; end
            if isempty(T.(currentnode).parent), T(1).(currentnode).parent = parentnode; end
            if ~strcmp(T.(currentnode).parent,parentnode), error('two parents for the same node'), end
        end % next node in path
    end % next path
end % next path length
end

%ISINCLUDED returns p{i}(1:n) matching s
function [i,n] = isincluded(p,s)
np = length(p);
n = min(length(s),max(cellfun(@length,p)));
s = s(1:n);
tst = zeros(np,1);
for ip=1:np
    tst(ip) = cellcmp(p{ip}(1:min(n,length(p{ip}))),s);
end
i = find(tst);
end