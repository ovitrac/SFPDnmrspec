function [treename,treeind,mapout,succout] = buildmarkov(list,parent,varargin)
%BUILDMARKOV builds a Markov chain based on a list keywords or values and a list of parents
%   [treename,treeind] = buildmarkov(list,parent)
%       treename: nx1 cell array giving all possible n paths as names (taken from list)
%                 structure generated by fmecaengine
%        treeind: nx1 cell array giving all possible n paths as indices
%   [treename,treeind,map,succ] = buildmarkov(list,parent,'property',value)
%            Implemented properties/values
%               sort = 'none' (default), 'ascend' or 'descend'
%            map: mxn array (m=max path depth) matching treeind but coded as find_multiple does with format=1
%           succ: lxn array (l=max number of children) coding for the list of children (coded as find_multiple does with format=1)
%
% example
%   list =   {'A1' 'B1' 'C1' 'A2' 'A3' 'A4' 'C3' 'C2' 'AA1' 'AA2' 'AB1' 'AB2'}
%   parent = {''   ''   ''   'A1' 'A2' 'A3' 'C2' 'C1' 'A1'  'AA1' 'AA1' 'AB1'} 
%   [pathsnames,pathsind]=buildmarkov(list,parent)
%     pathsnames{:}   
%     ans = 
%         'A1'    'A2'    'A3'    'A4'
%     ans = 
%         'A1'    'AA1'    'AA2'
%     ans = 
%         'A1'    'AA1'    'AB1'    'AB2'
%     ans = 
%         'B1'
%     ans = 
%         'C1'    'C2'    'C3'
%
%   SEE ALSO: FMECAENGINE, FMECASINGLE, LOADFMECAENGINEDB, KEY2KEY, iSMEMBERLIST

% MIGRATION 2.0 - 08/04/11 - INRA\Olivier Vitrac - rev. 24/05/11

% Revision history
% 08/04/11 release candidate, to be used along the M2 of Audrey Goujon
% 10/04/11 add succ as available output
% 26/04/11 remove the children of the virtual node succ(:,1:end-1) instead of succ
% 28/04/11 replace NaN by '' in parent
% 24/05/11 list as a struct generated by fmecaengine

% default
options_default = struct('sort','none');

% arg check
if isstruct(list)
    tmp = list; list = fieldnames(list);
    if nargin<2, parent = {}; end
    if isempty(parent), parent  = cellfun(@(x) tmp.(x).parent,list,'UniformOutput',false); end
end
nlist = length(list);
if length(unique(list))~=nlist, error('the list includes repetitions'), end
if ~iscellstr(parent)
    invalidparent = cellfun(@(p) isnan(p(1)),parent); parent(invalidparent) = {''};
end
options = argcheck(varargin,options_default);

% data coding
%   id: indexed list
% pred: list of predecessors (singleton)
% succ: list of sucessors (0 or more)
id = 1:nlist;
pred = cellfun(@(p) find(ismember(list,p)),parent,'UniformOutput',false);
pred(cellfun('isempty',pred)) = {0};
pred = [pred{:}];
succ = find_multiple(id,pred,1);
succ = [succ zeros(size(succ,1),nlist-size(succ,2))];
root = id(pred==0); nroot = length(root);

% use a virtual root node to start the process recursively
succ(1:nroot,id(end)+1) = root;
map = family(id(end)+1,succ); 

% optional sorting
mape = cellfun(@(p) p(p>0),num2cell(map,1),'UniformOutput',false); % explode maps
if strcmpi(options.sort,'ascend') || strcmpi(options.sort,'descend')
    siz = cellfun(@(p) length(p),mape);
    [~,order] = sort(siz,options.sort);
    mape = mape(order);
    map = map(:,order);
end

% outputs
treename = cellfun(@(p) list(p),mape,'UniformOutput',false)';
if nargout>1, treeind = cellfun(@(p) id(p),mape,'UniformOutput',false)'; end
if nargout>2, mapout = map; end
if nargout>3, succout = succ(:,1:end-1); end

end % end function

% PRIVATE recursive function to descend trees
% data are stored as find_multiple does with format=1
% Increase maxrecursion if needed
function tree=family(father,descendantlist)
children = descendantlist(:,father);
nchildren = length(find(children>0));
if nchildren<1
    tree = []; % previous node was terminal
else
    tree = zeros(0,nchildren);
    nleaves = 0;
    for i=1:nchildren
        tmp = family(children(i),descendantlist);
        if isempty(tmp) % single leave to append
            tree(1,nleaves+1) = children(i);
            nleaves = nleaves + 1;
        else % full tree to append
            ind = nleaves+(1:size(tmp,2));
            tree(1,ind) = children(i);
            tree(2:(size(tmp,1)+1),ind) = tmp;
            nleaves =nleaves + size(tmp,2);
        end
    end
end
end % end function